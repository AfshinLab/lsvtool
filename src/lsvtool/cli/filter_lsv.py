"""
This code is to filter a vcf files 
it compatible with SURVIVOR, with additional filtration of lengths and quality.
"""

###
# This code is to filter vcf files generated by different tools
# It expects the following columns...
# input <- vcf file
# output -> filtered VCF and bedpe file 
###

import os, sys, vcf
import pandas as pd

def add_arguments(parser):
    # parser = argparse.ArgumentParser(
    #     description='''This code is to filter a bedpe file  generated by NAIBR, LinkedSV, Pacbio or 10X, and make 
    #     it compatible with SURVIVOR, with additional filtration of lengths and quality.''',
    #     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument( "-f", "--file_name", default=None,
        help="bedpe file generated from NAIBR")
    parser.add_argument("-t", "--svtype", default=None,
        help="SV type to keep [DEL, DUP, INV]")
    parser.add_argument("-M", "--maxlength", default=10000000,type=int,
        help="Max SV length to keep")
    parser.add_argument("-m", "--minlength", default=1000,type=int,
        help="Min SV length to keep")
    parser.add_argument("-q", "--quantile", default=0.5, type=float,
        help="Remove SV with QC less than the quantile (for NAIBR only)")
    parser.add_argument("-d", "--max_distance", default=1000,type=int,
        help="Max distance between SV to be merged")
    parser.add_argument("-bl", "--blacklists", default=None, type=str,
        help="blacklist (regions to discard) 3-columns bed file(s) separated by commas (,) for more than one file! (no spaces) ")
    #todo type=list, action='append', nargs='+' 
    parser.add_argument("-wl", "--whitelists", default=None, type=str,
        help="whitelist (regions to only include) 3-columns bed file(s) separated by commas (,) for more than one file! (no spaces) ")
    parser.add_argument("-o", "--output_dir", default=".", type=str,
        help="Output directory, Default is out ")


# Converting functions
def check_ext(filename):
    if  str(filename).endswith(".vcf") or str(filename).endswith(".vcf.gz"):
        pass
    else:
        sys.exit("input file is not vcf or vcf.gz")

# naibr filter functionls
def filter_naibr(df,quantile):
    cuttoff=df.quality.quantile(q=quantile)
    if str(cuttoff).isdigit():
        print("The top ",round((1-quantile)*100), "% of the QC will be kept", sep="")
        print("Cut off set: ",cuttoff,sep="")
        df = df[df.quality >= cuttoff]
    #     #hist = df.qual_score.hist(bins=df.shape[0])
    #     matplotlib.use('Agg')
    #     plt.hist(df.qual_score, bins=df.shape[0])
    #     plt.axvline(x=cuttoff, color='r', linestyle='dashed', linewidth=1,
    #                 label= round(cuttoff,2))
    #     plt.legend(loc='upper right')
    #     plt.xlim(0, 5000)
    #     #plt.show(hist)
    #     plt.savefig("{0}QC_filter_{1}.pdf".format(aa.output_dir,file_name))
    #     plt.close()
        df = df[df.quality >= cuttoff]
    else:
        print("There is no values in quality column, no filtration is done!")
    return df

#VCF file is 10 columns, bedpe output is 12 columns
def vcf_to_bedpe(filename):
        vcflist = vcf.Reader(filename=filename)
        bedpelist = []
        for record in vcflist:
                if record.start < 0:
                        record.start = 0
                if not record.FILTER:
                        record.FILTER = "."
                if record.CHROM.isdigit() or record.CHROM.lower() in ['x','y'] :
                        record.CHROM = "chr" + record.CHROM
                try:
                        newline=[record.CHROM,record.start,record.end,
                                record.CHROM,record.INFO['END'],record.INFO['END']+1,
                                record.var_subtype, record.ID, record.INFO['END']-record.start, record.QUAL,
                                "_".join(record.FILTER),record.INFO]
                except:
                        continue
                bedpelist.append(newline)
        bedpelist = pd.DataFrame(bedpelist,columns=["#chr","start1","end1",
                                            "chr","start2","end2",
                             "type","ID","length","quality","filter","INFO"])
        
        return bedpelist

### The following 2 functions are only for deletions, inversion and duplication,
### with an assumption that start1 = end1, start2 = end2, chr1 = chr2
def bedpe_to_bed(df):
    df2 = pd.concat([df.iloc[:,0:2], df.iloc[:,5], df.iloc[:,6:]], axis=1)
    return(df2)

def bed_to_bedpe(df):
    df2 = pd.concat([df.iloc[:,0:2], df.iloc[:,1]+1,df.iloc[:,0], df.iloc[:,2],df.iloc[:,2]+1,
                     df.iloc[:,3:]], axis=1)
    col_names = df2.columns.tolist()
    col_names[0:6] = ["chrom1", "start1", "stop1", "chrom2", "start2", "stop2"]
    df2.columns = col_names
    return(df2)

def sort_natural(df):
    x = list(range(1, 23))
    x.extend(["X", "Y", "EBV"])
    x = ["chr" + str(c) for c in x]
    #natsorted(df.iloc[:,0].unique())) can be used instead of x
    df.iloc[:,0] = pd.Categorical(df.iloc[:,0], ordered=True, categories=x)
    df = df.sort_values(by=df.columns[0:2].tolist())
    return(df)


def main(args):
    aa = args
    filerootname = aa.file_name.replace(".vcf.gz","")
    filerootname = filerootname.replace(".vcf","")
    
    # make the code for blacklists files
    if not str(aa.output_dir).endswith("/"):
        aa.output_dir = aa.output_dir + "/"

    if not os.path.exists(aa.output_dir):
        os.makedirs(aa.output_dir)

    # START:
    ########
    # Read files
    print("\n===========================\nChecking the vcf file:\n{}\n".format(filerootname))
    
    check_ext(aa.file_name)
    
    bedpelist = vcf_to_bedpe(aa.file_name)

    bedpelist = sort_natural(bedpelist)
    
    # Filters
    ##low quality
    bedpelist = bedpelist[bedpelist["filter"].str.find("LOWQ") == -1]
    
    ##type
    if aa.svtype:
        bedpelist = bedpelist[bedpelist.type == aa.svtype]
    
    if aa.maxlength:
        bedpelist = bedpelist[bedpelist["length"]<=aa.maxlength]
    
    if aa.minlength:    
        bedpelist = bedpelist[bedpelist["length"]>=aa.minlength]

    if  "naibr" in filerootname:
        if aa.quantile>0: 
            print("naibr is in the file name, and perc in config file is not 0 ==> filtereing..")
            bedpelist = filter_naibr(bedpelist,aa.quantile)
        else:
            print("File is naibr but no quality filtration is applied on the list")

    df = bedpe_to_bed(bedpelist)
    bedfile = aa.output_dir + filerootname + "_filtered_sorted.bed"
    bedfile_merged = aa.output_dir + filerootname + "_filtered_sorted_merged.bed"
    bedpefile_merged = aa.output_dir + filerootname + "_filtered_sorted_merged.bedpe"
    vcffile_merged = aa.output_dir + filerootname + "_filtered_sorted_merged.vcf"

    df.to_csv(bedfile, index=None, header=None, sep='\t')
    os.system("bedtools merge -i {} -c 4,5,6,7,8,9 -o first,collapse,max,mean,first,count -d {} > {}_temp".format(bedfile,aa.max_distance,bedfile_merged))


### Filter white and black lists from the merged file ###
    blacklist_code = ""
    if aa.blacklists:
        for file in aa.blacklists.split(","):
            if os.path.exists(file):
                blacklist_code = blacklist_code + " -b " + file
            else:
                print("File \"{}\" does not exist so it will be skipped".format(file))
        blacklist_code = blacklist_code + " "

    whitelist_code = ""
    if aa.whitelists:
        for file in aa.whitelists.split(","):
            if os.path.exists(file):
                whitelist_code = whitelist_code + " -b " + file
            else:
                print("File \"{}\" does not exist so it will be skipped".format(file))
        whitelist_code = whitelist_code + " "

    if (blacklist_code):
        os.system("bedtools intersect -v -a {0}_temp {1} > {0}_temp2".format(bedfile_merged,blacklist_code))
    else:
        os.system("cp {0}_temp {0}_temp2".format(bedfile_merged))

    if whitelist_code:
        os.system("bedtools intersect -a {0}_temp2 {1} -wa > {0}".format(bedfile_merged,whitelist_code))
    else:
        os.system("cp {0}_temp2 {0}".format(bedfile_merged))


    df = pd.read_csv(bedfile_merged,header=None, sep='\t')
    df = bed_to_bedpe(df)
    df.to_csv(bedpefile_merged, index=False, header=False, sep='\t')

    os.system("SURVIVOR bedpetovcf {} {}_temp".format(bedpefile_merged, vcffile_merged))
    os.system("less {0}_temp | sed s'/STRANDS=[0-9][- 0-9];//'g > {0}".format(vcffile_merged))
    os.system("rm {0} {1} {1}_temp {1}_temp2 {2}_temp".format(bedfile, bedfile_merged, vcffile_merged))
