"""
This code is to filter a vcf files 
it compatible with SURVIVOR, with additional filtration of lengths and quality.
"""

###
# This code is to filter vcf files generated by different tools
# It expects the following columns...
# input <- vcf file
# output -> filtered VCF and bedpe file 
###

import os
import sys
from pathlib import Path
import logging

import vcf
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt

logger = logging.getLogger(__name__)


def add_arguments(parser):
    parser.add_argument( "-f", "--file_name", required=True,
        help="vcf file")
    parser.add_argument("-t", "--svtype",
        help="SV type to keep [DEL, DUP, INV]")
    parser.add_argument("-M", "--maxlength", default=10000000,type=int,
        help="Max SV length to keep. Default: %(default)s")
    parser.add_argument("-m", "--minlength", default=1000,type=int,
        help="Min SV length to keep. Default: %(default)s")
    parser.add_argument("-q", "--quantile", default=0.5, type=float,
        help="Remove SV with QC less than the quantile (for NAIBR only). Default: %(default)s")
    parser.add_argument("-d", "--max_distance", default=1000,type=int,
        help="Max distance between SV to be merged. Default: %(default)s")
    parser.add_argument("-bl", "--blacklists",
        help="blacklist (regions to discard) 3-columns bed file(s) separated by commas (,) for more than one file! (no spaces) ")
    #todo type=list, action='append', nargs='+' 
    parser.add_argument("-wl", "--whitelists",
        help="whitelist (regions to only include) 3-columns bed file(s) separated by commas (,) for more than one file! (no spaces) ")
    parser.add_argument("-o", "--output_dir", default=Path().cwd(), type=Path,
        help="Output directory, Default: %(default)s (CWD)")


# Converting functions
def check_ext(filename):
    if str(filename).endswith(".vcf") or str(filename).endswith(".vcf.gz"):
        pass
    else:
        sys.exit("input file is not vcf or vcf.gz")


# naibr filter functionls
def filter_naibr(df, quantile, outputpath, file_name):
    if pd.api.types.is_numeric_dtype(df.quality):
        cuttoff=df.quality.quantile(q=quantile)
        print("The top ",round((1-quantile)*100), "% of the QC will be kept", sep="")
        print("Cut off set: ",cuttoff,sep="")
        df = df[df.quality >= cuttoff]
        #hist = df.qual_score.hist(bins=df.shape[0])
        matplotlib.use('Agg')
        plt.hist(df.quality, bins=df.shape[0])
        plt.axvline(x=cuttoff, color='r', linestyle='dashed', linewidth=1,
                     label= round(cuttoff,2))
        plt.legend(loc='upper right')
        plt.xlim(0, 5000)
        #plt.show(hist)
        plt.savefig("{0}QC_filter_{1}.pdf".format(outputpath,file_name))
        plt.close()
        df = df[df.quality >= cuttoff]
    else:
        print("There is no values in quality column, no filtration is done!")
    return df


#VCF file is 10 columns, bedpe output is 12 columns
def vcf_to_bedpe(filename):
    reader = vcf.Reader(filename=filename)
    if "END" not in reader.infos:
        logger.warning("Missing END information in VCF header")

    bedpelist = []
    for record in reader:
        if record.start < 0:
            record.start = 0

        # Keep records with PASS (returns FILTER as empty list) or '.'
        if record.FILTER and "." not in record.FILTER:
            continue

        if record.CHROM.isdigit() or record.CHROM.lower() in ['x','y'] :
            record.CHROM = "chr" + record.CHROM

        if "END" not in record.INFO:
            logger.debug(f"Record missing 'END' in info: {record}")
            continue

        newline = [
            record.CHROM,
            record.start,
            record.end,
            record.CHROM,
            record.INFO['END'],
            record.INFO['END']+1,
            record.var_subtype, 
            record.ID, 
            record.INFO['END']-record.start, # Length
            record.QUAL,
            ",".join(record.FILTER),
            record.INFO
        ]
        bedpelist.append(newline)
    bedpelist = pd.DataFrame(bedpelist, columns=["#chr","start1","end1", "chr","start2","end2",
                                                 "type","ID","length","quality","filter","INFO"])
    
    return bedpelist


### The following 2 functions are only for deletions, inversion and duplication,
### with an assumption that start1 = end1, start2 = end2, chr1 = chr2
def bedpe_to_bed(df):
    df2 = pd.concat([df.iloc[:,0:2], df.iloc[:,5], df.iloc[:,6:]], axis=1)
    return(df2)


def bed_to_bedpe(df):
    df2 = pd.concat([df.iloc[:,0:2], df.iloc[:,1]+1,df.iloc[:,0], df.iloc[:,2],df.iloc[:,2]+1,
                     df.iloc[:,3:]], axis=1)
    col_names = df2.columns.tolist()
    col_names[0:6] = ["chrom1", "start1", "stop1", "chrom2", "start2", "stop2"]
    df2.columns = col_names
    return(df2)


def sort_natural(df):
    x = list(range(1, 23))
    x.extend(["X", "Y", "EBV"])
    x = ["chr" + str(c) for c in x]
    #natsorted(df.iloc[:,0].unique())) can be used instead of x
    df.iloc[:,0] = pd.Categorical(df.iloc[:,0], ordered=True, categories=x)
    df = df.sort_values(by=df.columns[0:2].tolist())
    return(df)


def main(args):
    print(vars(args))
    filerootname = args.file_name.replace(".vcf.gz","").replace(".vcf","")
    args.output_dir.mkdir(exist_ok=True)

    # START:
    ########
    # Read files
    print("\n===========================\nChecking the vcf file:\n{}\n".format(filerootname))
    
    check_ext(args.file_name)
    
    bedpelist = vcf_to_bedpe(args.file_name)

    bedpelist = sort_natural(bedpelist)
    
    ##type
    if args.svtype:
        bedpelist = bedpelist[bedpelist.type == args.svtype]
    
    if args.maxlength:
        bedpelist = bedpelist[bedpelist["length"]<=args.maxlength]
    
    if args.minlength:    
        bedpelist = bedpelist[bedpelist["length"]>=args.minlength]

    if  "naibr" in filerootname:
        if args.quantile>0: 
            print("naibr is in the file name, and perc in config file is not 0 ==> filtereing..")
            bedpelist = filter_naibr(bedpelist,args.quantile,args.output_dir,filerootname)
        else:
            print("File is naibr but no quality filtration is applied on the list")

    df = bedpe_to_bed(bedpelist)
    bedfile = args.output_dir / f"{filerootname}_filtered_sorted.bed"
    bedfile_merged = args.output_dir / f"{filerootname}_filtered_sorted_merged.bed"
    bedpefile_merged = args.output_dir / f"{filerootname}_filtered_sorted_merged.bedpe"
    vcffile_merged = args.output_dir / f"{filerootname}_filtered_sorted_merged.vcf"

    df.to_csv(bedfile, index=None, header=None, sep='\t')
    if args.max_distance > 0:
        os.system("bedtools merge -i {} -c 4,5,6,7,8,9 -o first,collapse,max,mean,first,count -d {} > {}_temp".format(bedfile,args.max_distance,bedfile_merged))
    else:
        os.system("cp {} {}_temp".format(bedfile, bedfile_merged))


    ### Filter white and black lists from the merged file ###
    blacklist_code = ""
    if args.blacklists is None:
        for file in args.blacklists.split(","):
            if os.path.exists(file):
                blacklist_code = blacklist_code + " -b " + file
            else:
                print("File \"{}\" does not exist so it will be skipped".format(file))
        blacklist_code = blacklist_code + " "

    whitelist_code = ""
    if args.whitelists is None:
        for file in args.whitelists.split(","):
            if os.path.exists(file):
                whitelist_code = whitelist_code + " -b " + file
            else:
                print("File \"{}\" does not exist so it will be skipped".format(file))
        whitelist_code = whitelist_code + " "

    if blacklist_code:
        os.system("bedtools intersect -v -a {0}_temp {1} > {0}_temp2".format(bedfile_merged,blacklist_code))
    else:
        os.system("cp {0}_temp {0}_temp2".format(bedfile_merged))

    if whitelist_code:
        os.system("bedtools intersect -a {0}_temp2 {1} -wa > {0}".format(bedfile_merged,whitelist_code))
    else:
        os.system("cp {0}_temp2 {0}".format(bedfile_merged))

    try:
        df = pd.read_csv(bedfile_merged,header=None, sep='\t')
        df = bed_to_bedpe(df)
        df.to_csv(bedpefile_merged, index=False, header=False, sep='\t')
    except:
        print("All SVs were filtered out!")
        with open(bedpefile_merged, "w") as f:
            f.write("#")

    os.system("SURVIVOR bedpetovcf {} {}_temp".format(bedpefile_merged, vcffile_merged))
    os.system("less {0}_temp | sed s'/STRANDS=[0-9][- 0-9];//'g > {0}".format(vcffile_merged))
    os.system("rm {0} {1} {1}_temp {1}_temp2 {2}_temp".format(bedfile, bedfile_merged, vcffile_merged))
